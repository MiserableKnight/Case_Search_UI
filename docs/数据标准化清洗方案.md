# 数据标准化清洗方案

## 问题背景

用户手动添加数据到 parquet 文件时，这些数据绕过了清洗流程，导致：
- 飞机序列号格式不统一（有的3位，有的5位）
- 运营人名称不统一（有的"中国南方航空股份有限公司"，有的"南航"）
- 维修ATA类型不一致（有的整数，有的字符串）
- 部件号空值不统一（有的None，有的"无"）

**影响**：数据不一致会导致去重失败、查询错误

## 解决方案

在备份流程中自动清洗数据，确保每次备份的数据都是标准化的。

```
备份流程：
  1. 检查源目录 (现有)
  2. 清洗 Parquet 文件 (新增) ← 在这里清洗
  3. 创建备份目录 (现有)
  4. 复制文件 (现有)
  5. 更新记录 (现有)
```

## 实现计划

### 1. 新建 `scripts/data_cleaner.py`

创建独立的数据清洗服务类，负责清洗 parquet 文件。

**核心功能**：
- 读取 `faults.parquet` 文件
- 根据"数据类型"列分别清洗：
  - `数据类型 == "故障报告"` → 使用 `FaultReportProcessor.clean_data()`
  - `数据类型 == "部件拆换记录"` → 使用 `RAndIRecordProcessor.clean_data()`
- 比较清洗前后数据，检测变更
- 仅在数据有变化时保存文件（幂等性）
- 详细的日志记录

**关键方法**：
```python
class DataCleaner:
    def clean_and_save_if_needed(self) -> dict:
        """清洗并仅在检测到变化时保存"""

    def _clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """根据数据类型分类清洗"""

    def _has_changes(self, df1, df2) -> bool:
        """检测数据是否发生变化"""
```

### 2. 修改 `scripts/backup_manager.py`

在 `BackupManager` 类中集成清洗步骤。

**添加的方法**：
```python
def _clean_parquet_files(self) -> dict:
    """清洗 source_dir 中的 parquet 文件（在备份前）"""
```

**修改的方法**：
```python
def create_backup(self) -> bool:
    """执行备份操作"""
    # 检查源目录
    if not self._check_source_directory():
        return False

    # ========== 新增：清洗 parquet 文件 ==========
    self.logger.info("开始清洗 parquet 文件...")
    clean_result = self._clean_parquet_files()
    # 清洗失败不中断备份，只记录警告
    # ========== 清洗步骤结束 ==========

    # 创建备份目录、复制文件...
```

### 3. 复用现有清洗逻辑

**无需修改**，直接使用：
- `app/core/data_processors/fault_report_processor.py`
  - `FaultReportProcessor.clean_data()` 方法
- `app/core/data_processors/r_and_i_record_processor.py`
  - `RAndIRecordProcessor.clean_data()` 方法

这些方法已经实现了：
- 运营人名称标准化
- 机型清洗
- 飞机序列号5位标准化（添加前导零）
- 维修ATA字符串转换
- 空值统一处理（None → "无"）

## 关键设计决策

### 1. 非阻塞设计
- **清洗失败不影响备份**：即使清洗失败，备份流程继续进行
- **部分失败处理**：某种数据类型清洗失败，保留该部分原始数据，继续清洗其他类型

### 2. 幂等性保证
- 多次清洗结果一致
- 通过 `_has_changes()` 方法检测变更
- 没有变化时不保存文件

### 3. 变更检测
- 使用 `pandas.testing.assert_frame_equal()` 比较清洗前后数据
- 仅在检测到变化时保存文件
- 避免不必要的磁盘写入

### 4. 详细日志
- 记录每种数据类型的清洗情况
- 统计处理行数和检测到的变化
- 清洗失败时记录详细错误信息

## 实现文件

### 新建文件
- `scripts/data_cleaner.py` - 数据清洗服务类

### 修改文件
- `scripts/backup_manager.py` - 添加 `_clean_parquet_files()` 方法，修改 `create_backup()` 方法

### 参考文件（无需修改）
- `app/core/data_processors/fault_report_processor.py`
- `app/core/data_processors/r_and_i_record_processor.py`
- `app/core/data_processors/data_import_processor.py`

## 测试验证

### 1. 功能测试

**创建脏数据**：
```python
import pandas as pd

# 读取现有数据
df = pd.read_parquet("data/raw/faults.parquet")

# 人为制造脏数据
df.loc[0, '运营人'] = '中国南方航空股份有限公司'  # 不规范
df.loc[0, '飞机序列号'] = '123'  # 不足5位
df.loc[0, '维修ATA'] = 25  # 应该是字符串

# 保存
df.to_parquet("data/raw/faults.parquet", index=False)
```

**运行备份**：
```bash
python scripts/backup_manager.py
```

**验证结果**：
```python
# 读取清洗后的数据
df = pd.read_parquet("data/raw/faults.parquet")

# 检查
print(df.loc[0, '运营人'])  # 应该是"南航"
print(df.loc[0, '飞机序列号'])  # 应该是"00123"
print(df.loc[0, '维修ATA'])  # 应该是"25"（字符串）
```

### 2. 幂等性测试

再次运行备份，日志应该显示：
```
INFO - 数据无需清洗，未检测到变化
```

### 3. 集成测试

完整的备份流程测试：
1. 创建脏数据
2. 运行 `scripts/run.bat`（程序启动时会触发智能备份）
3. 检查日志 `data/backup.log`
4. 验证备份数据已清洗
5. 再次运行备份，验证幂等性

## 日志示例

### 成功清洗（有变化）
```
INFO - 开始清洗 parquet 文件: data/raw/faults.parquet
INFO - 读取到 1500 行数据
INFO - 数据类型分布: {'故障报告': 1200, '部件拆换记录': 300}
INFO - 开始清洗 '故障报告' 数据 (1200 行)
INFO - 飞机序列号已标准化为5位数字格式
INFO - 维修ATA已转换为字符串类型
INFO - '故障报告' 数据清洗完成
INFO - 开始清洗 '部件拆换记录' 数据 (300 行)
INFO - 飞机序列号已标准化为5位数字格式
INFO - '部件拆换记录' 数据清洗完成
INFO - 检测到数据变化，已保存清洗后的数据
```

### 无需清洗（无变化）
```
INFO - 开始清洗 parquet 文件: data/raw/faults.parquet
INFO - 读取到 1500 行数据
INFO - 数据类型分布: {'故障报告': 1200, '部件拆换记录': 300}
INFO - 数据无需清洗，未检测到变化
```

## 使用方式

### 自动使用（推荐）
备份时自动清洗，无需额外操作：
```bash
# 标准备份（自动清洗）
python scripts/backup_manager.py

# 智能备份（程序启动时自动触发）
# scripts/run.bat 会调用 smart_backup_check()
```

### 单独使用清洗功能
```python
from scripts.data_cleaner import clean_parquet_file

result = clean_parquet_file("data/raw/faults.parquet")
print(result)
```

## 优势

1. **自动化**：备份时自动清洗，无需手动干预
2. **幂等性**：多次运行结果一致，不会重复处理
3. **非阻塞**：清洗失败不影响备份
4. **复用性**：使用现有清洗逻辑，避免重复代码
5. **可扩展**：易于添加新的数据类型或清洗规则
6. **安全性**：仅在检测到变化时保存，避免意外覆盖

## 总结

这个方案在备份流程中集成了数据清洗功能，确保每次备份的数据都是标准化的。通过复用现有的清洗逻辑、变更检测和幂等性设计，既保证了数据质量，又不影响现有备份流程的稳定性和性能。
